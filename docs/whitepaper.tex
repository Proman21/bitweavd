\documentclass[10pt,a4paper,onecolumn]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{url}
\usepackage{varioref}
\author{Liam Edwards-Playne \textless liamz.co\textgreater}
\date{June 1, 2013}
\title{bitWeav — a web application for scalable decentralised peer-to-peer  communications}
\begin{document}
\maketitle
\begin{abstract}
\end{abstract}

\section{Introduction}
\label{intro}
In the last half-decade we have seen how the microblogging atmosphere of \emph{Twitter} has proven the value of online communication. The fundamental principle of microblogging, which is the compacting of ideas into 140 characters, has sparked a revolution in how we communicate. Users could spark a conversation on topics (tags) with strangers, discussing anything and everything in real-time. Through trending topics, this public yet often concealed discussion platform which is online communication could give rise to the sharing of influential ideas and the stirring of the masses. We could see this in events such as the Egyptian Revolution of 2011 and Occupy Wall Street. Such an invaluable resource must be kept sustainable, but we have seen that due to the centralised nature of this tool, as well as its issues with corporate control, there is a need for an alternative. 

A similar, older and more sustainable platform is \emph{IRC}. Like \emph{Twitter}, \emph{IRC} facilitated public text-based discussion on topics (channels). It had its advantages and disadvantages as it used a moderator-based group discussion device called a channel, but the user bases of such were fragmented across differing \emph{IRC} networks. Nonetheless, its more advanced organised discussion led to it becoming the key communications tool for 'hackers'. Hackers found the setup requiring minimum personal details, in combination with the simplistic and programmable interface which is the \emph{IRC} protocol, allowed for high-quality discussions that focused on the content. 

Finally there was \emph{Skype}. The unique feature of Skype was its alternate method of communication — video chat. It allowed individuals to talk privately and securely with ease. Perhaps the most significant but relatively unknown aspect of \emph{Skype} was its decentralised and peer-to-peer network architecture. Although \emph{Skype} wasn't truly decentralised, it did show that service could be improved through such a system. Alas after the acquisition by \textit{Microsoft}, the platform headed downhill, instead revoking the previous security and decentralised nature of the application in favour of centralisation. Users could no longer rely on the simple yet secure platform which it had a strong image for, and have been lost in a myriad of alternatives since. 

One such alternative I have come across was \emph{BitMessage}. \emph{BitMessage} is a text-based communications protocol that rivals email, relying on a decentralised network of nodes to provide a peer-to-peer communications platform that is secure and easy to use. I commend the author of the application on these features and the effort it had taken to construct such a project, but despite these things the protocol had numerous faults. Its broadcast mechanism which resembled a gossip protocol was not to be desired. There had also been numerous reported vulnerabilities, but these extend the scope of my interest. I set out to build an alternative, that would combine the features of \emph{Twitter}, \emph{IRC} and \emph{Skype}, while retaining the sustainable nature of \emph{Bitmessage}. It was to be an experiment in decentralised peer-to-peer innovation.

\section{Objectives}
Recent innovations and technologies have brought together a feasible environment for the creation of such a solution. The introduction of in-browser peer-to-peer networking API particularly struck me as a fantastic opportunity to implement an application that was decentralised and had magnificent ease-of-use. Another significant aspect was a novel decentralised peer-to-peer publish-subscribe architecture called \textit{PolderCast}, which featured a publish-subscribe system that distributed messages only to the nodes who were interested, in a scalable manner.

In this paper I describe both the theory of \textit{bitWeav} and its web-based implementation called \textit{Weav}. To guide the development of \textit{bitWeav}, I formulated a list of objectives that expressed the key features necessary for its completion.
\begin{enumerate}
\item \textbf{Decentralised}: we must not rely on any set of nodes to provide for any other set of nodes, in the circumstances where if their connection were severed it would produce irreparable damage to the network. 

\item \textbf{Open}: we must rely totally on open technologies and likewise publish all concepts/implementations under a fair license.

\item \textbf{Simple}: the theory and implementation must be as simple as possible. the content distributed by the system must be contained within a single type — the message. All messages, contacts and topics must be uniquely identified by a single data type — the ID.

\item \textbf{Easy to use}: like Twitter and Skype the initial concept must be easy to understand for a user of these platforms, and likewise so must the user experience.

\item \textbf{Topic-enabled}: messages must be able to be categorised under multiple topics using tags, and distributed to those who are interested.

\item \textbf{Threaded}: threaded messaging must be inbuilt, wherein messages can be in reply to other messages, and descend from a common root (a thread)

\item \textbf{Privacy-enabled}: private distribution of messages must be supported, whereby only specific contacts will receive messages on a specific topic. These private conversations should pertain to the off-the-record messaging protocol. 

\item \textbf{Media-enabled}: contacts must be able to communicate through other mediums like video and audio. 

\item \textbf{Secure}: the authenticity, integrity, and completeness of public content sent within the network must be preserved by the system and independently verifiable by nodes. Replay attacks must be defended against. Forward secrecy must be ensured for private messages.
\end{enumerate}

\section{Contacts and Messages}
\label{ContactsAndMessages}
At the core of \textit{bitWeav} are contacts and messages. Contacts are the users who access the \textit{bitWeav} network, and messages are the basis of their communications.

\subsection*{Contacts}
A contact is a generic term for machines and users accessing the \textit{bitWeav} network. Contacts authenticate using their 512 bit elliptic curve \textbf{public/private key-pair}. They are identified by the computation of an identification function (described below) over the public key, which is referred to as their address. Since the public key is mathematically bound to the private key, this process makes forging an address infeasible.

The network operation of contacts is described in chapter~\ref{network}.

\subsection*{Messages}
A \textbf{message} is a generic container for micro-content. Micro-content is the basis of the micro-publishing idea: when content is small, it introduces constraints on users to relay more information into fewer words.

The bulk of the message is the \textbf{content}. The content is a maximum of 160 bytes in size and is interpreted as an array of UTF-8 characters. UTF-8 was chosen as the encoding, as it is a standardised format that has wide usage on the Web and has sufficient support for other alphabets. The 160 character limit (for Western alphabets) was chosen because it has shown sufficient for expressing ideas (text messages, Twitter 'tweets') in threaded communications. 

The content can contain two types of markup: \textbf{hashtags} and \textbf{URIs}. Hashtags, which are space-delimited strings that begin with a hash '\#', are used to identify topics that a message is associated with. A message may have multiple hashtags. The other form of markup supported are links, which are URIs which can be used to link to web pages and torrents (using the magnet URI scheme). In both cases Weav will automatically create a clickable link to the tag or the URI.

Finally all messages include a \textbf{from} field, which is the public key

These features alone provide something similar to Twitter tweets and IRC messages, but \textbf{lack any structure to the conversation}. Before I explain how threads are implemented, I must first describe how they are identified — the ID.

\section{Identification}
\label{id}
As a requirement of the \emph{simple} objective, we must have a single system of identification for contacts, messages and topics. I define a type called the \textbf{ID} to identify all of these items. 

The purpose of the ID is to provide a unique fixed-size identifier for a contact, message or hashtag. I employ the Bitcoin address generation algorithm\cite{btcAddr}, as it has shown to provide a simplistic and secure identification format. It is detailed as follows:
\begin{enumerate}
\item Having some arbitrary array of data as input to the ID function — the content.
\item Perform SHA2-256 hashing on the content.
\item Perform RIPEMD-160 hashing on the result of the SHA2-256.
\item Prepend the version byte 0x49 to the RIPEMD-160 hash.
\item Perform a double SHA2-256 hashing on the extended RIPEMD-160 result.
\item Append the first 4 bytes of the double SHA2-256 hashing (the checksum) to the extended RIPEMD-160 hash.
\item Optionally encode in Base58 for human representation. 
\end{enumerate}

Firstly for \textbf{contacts}, the ID is computed over the contact's public key. For \textbf{messages}, the ID is computed over the message's content (excluding the signature, which I describe in chapter~\ref{security}). Lastly for \textbf{topics} the ID is computed over the hashtag itself.

\section{Threading}
\subsection*{Reply-based threading}
There are two aspects to the threading of messages. The first is \textbf{reply-based threading} wherein a message is in response to another, which is what Twitter facilitates. The counterpart is \textbf{group-based threading}, wherein messages are part of a specific item of discussion on a topic — a thread. \textit{IRC} can be seen to support group-based threading, whereby each channel is a thread of messages. \textit{bitWeav} aims to support both of these. 

As each message can be identified using its ID, it is simply to implement reply-based threading. I define a field \textbf{reply}, which maps to the ID of the message that one is in reply to. There can only be one reply. 

\subsection*{Group-based threading}
The other type is group-based threading. In \textit{IRC} conversations, we have channels, which list a multitude of replies in a thread in chronological order. The model I described allows for a lossy form of discussion, but how would this channel concept be implemented? 

Firstly I define another field called the \textbf{root}, which maps to the ID of the original stimulus message for that conversation. When a node sends a message to a channel, they broadcast on the channel's topic. However this does not allow us to distinguish messages intended for a channel from normal microblogging 'noise'. Instead, we only listen for messages that are on a particular thread. 

This leaves us with only one problem, which is that of message ordering. The \emph{reply} field aids to develop a lossy ordering of messages. When we receive a message on the topic and thread we are listening on, we append it to the conversation thread according to which message it was in reply to. This allows for a lossy decentralised ordering of messages, but it is susceptible to nodes injecting messages into older parts of the chain. To guard against this, we employ a rolling metric to decide whether a message is recent enough: as the time differences between messages becomes smaller (and network synchronisation becomes harder), the accepted range for recent messages becomes larger. 

Due to the peer-to-peer nature of the overlay network, group messaging may be impeded by messages not being sent — unintentionally or on purpose. When we receive a message that is in reply to another message we have no record of, we contact the sending node to get the message. If the node does not respond, we discard their message. This method dissuades spammers from sending messages with falsified reply fields, as they will be flooded with queries. 

In this section I have outlined two optional fields: the 'reply' and 'root' fields. These fields can be used to implement traditional threaded conversation, like that found in IRC channels and Twitter replies.

\section{Security}
\label{security}
A principle objective of \textit{bitWeav} is to be secure and idea that security should be ubiquitous is fundamental to its design.

The first objective was that of transport security: nodes communicate via a secure transport protocol to preserve the authenticity, integrity, and completeness of data sent within the network. This is further described in chapter~\ref{impl}. 

The second is that of message authenticity. As discussed in chapter~\ref{ContactsAndMessages}, all contacts have an elliptic curve key-pair. Nodes use ECDSA with SHA-256 to sign their all of their messages, which is attached in the \textbf{signature} field. Because of this, any node can forward a message to others, which is an essential feature of \textit{Weav}'s message distribution strategy.

\section{Overlay Network}
\label{network}
The overlay network focuses on scalability. I employ a novel overlay network design that is orientated towards a publish-subscribe mechanism, called PolderCast. I will firstly outline the design of PolderCast and then describe my modifications to it.

\subsection*{PolderCast}
The Poldercast overlay consists of three layered network modules: \emph{CYCLON}, \emph{VICINITY} and \emph{RINGS}. Each module maintains its own view, managed by a separate gossiping protocol, which gossips periodically, asynchronously, and independently from the other two modules.

The system consists of an overlay network wherein nodes communicate using an RPC framework discussed in chapter ~\ref{impl}. Each node in the overlay network has a unique identifier, which is assumed to be sortable and to occupy a circular value space. PolderCast assumes that the underlying communication network is fully connected, in the sense that any node can send a message to any other node, provided it knows its contact details. 

The topic-based publish/subscribe communication system is organized around a set of topics, each having a separate unique identifier. Each node can play the role of a subscriber or publisher or both.

Each module maintains a node table called the \textbf{view}, wherein details for contacting nodes are contained and annotated by an age value. Whenever we send a message from any module, we increment the age value of all nodes. Whenever a node gossips with another  neighbour $Q$, it temporarily removes $Q$ from the respective module’s view, anticipating that it will respond and will be inserted anew. A node always selects to gossip with its oldest neighbour.

Lastly, we maintain two variables for each module: the view size $V$ and gossip size $G$. The \textbf{view size} defines the maximum number of neighbours to maintain, and is normally 20. The \textbf{gossip size} defines the maximum number of neighbours to be included in a gossip message, and is by default 20.

The network is based on a relatively small set of functions that provides for overlay network maintenance, message distribution and message retrieval.

\subsection*{Network Maintenance}
As briefly mentioned, we have three modules, each with their own gossiping protocol. Each module's gossiping protocol is based on the concept of a shuffle, a process whereby nodes initiate neighbour exchanges periodically, yet not synchronized, at a fixed period $T$. I describe this shuffling process for each module for an initiating node $P$. 

\subsubsection*{Cyclon}
This module operates at the lowest-level, being situated just above the layer where communications take place. It forms an overlay and maintains random links between nodes using an epidemic algorithm. Each peer knows a small, continuously changing set of other peers, called its neighbours, and occasionally contacts one to exchange some of their neighbours.

\paragraph*{Shuffling}
\begin{enumerate}
\item Select a neighbour $Q$ with the highest age among all neighbours, and a subset of $G-1$ other neighbours.
\item Replace $Q$'s entry with a new entry of age 0 and with $P$'s details.
\item Send the updated subset to $Q$.
\item Receive from $Q$ a subset of $G$ entries.
\item Discard entries pointing at $P$ and nodes that $P$ already knows of.
\item Verify entries are valid by establishing a connection to such nodes and discard any invalid entries.
\item Update $P$'s view to include all remaining entries, by firstly using empty slots (if any) and secondly replacing entries among the ones sent to $Q$.
\end{enumerate}

On reception of a shuffling query a node $Q$ replies by sending back a random subset of at most of $G$ its neighbours, and updates its own view to accommodate all received entries. 

It must be noted that this is susceptible to entry forgery, wherein the contact details of a node can be forged

\subsubsection*{Vicinity}


\subsubsection*{Rings}

Failure of a node to respond results in them being removed from the module's view.

\section{Conclusion}

\bibliography{whitepaper}

\end{document}
